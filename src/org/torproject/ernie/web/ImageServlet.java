package org.torproject.ernie.web;

import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.util.*;
import java.util.Date;
import java.text.*;
import java.sql.*;

import org.rosuda.REngine.Rserve.*;
import org.rosuda.REngine.*;

/**
 * Parameterizable graph, generated by R.
 *
 * TODO
 * All requests come from images/graphs/*
 * Get a list of valid graphs for this request, e.g.
 * networksize, exit-relays, etc. Parse parameters,
 * such as range=30d. If the graph is cached and
 * less than an hour old, serve that copy,
 * else regenerate it. All of this depends on whether
 * or not it is a default graph (which will be updated
 * automatically), or a custom graph (which will have
 * to be regenerated).
 */
public class ImageServlet extends HttpServlet {

  Constants c;

  public ImageServlet ()  {
    c = new Constants();
  }

  public void doGet(HttpServletRequest request,
      HttpServletResponse response) throws IOException,
      ServletException {

    Set<String> knownImages = new HashSet<String>(Arrays.asList(
          "72h,30d,90d,180d,all".split(",")));

    Set<String> knownGraphs = new HashSet<String>(Arrays.asList(
          "networksize,bandwidth," +
          "versions,platforms".split(",")));

    String graph = "networksize";
    String range = request.getParameter("range");
    String sp = request.getParameter("s");
    String ep = request.getParameter("e");
    String basePath = "/tmp/ernie/graphs/";
    String path;
    String start;
    String end;
    Calendar now = Calendar.getInstance(TimeZone.getTimeZone("UTC"));

      graph = request.getParameter("g").trim();

    //Set defaults in case anything goes wrong
    //Default range is 30 days
    now = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
    end = c.simpledf.format(now.getTime());
    now.add(Calendar.DATE, -30);
    start = c.simpledf.format(now.getTime());

    /*The options for the pre-defined graphs from the menu*/
    if (range != null)  {
      if (range.equals("all"))  {
        //Find lowest date and highest date
        try {
          PreparedStatement psAll = c.conn.prepareStatement(
            "select date(min(validafter)) as min, " +
            "date(max(validafter)) as max " +
            "from statusentry"
          );
          ResultSet rsAll = psAll.executeQuery();
          if (rsAll.next())  {
            start = rsAll.getString("min");
            end = rsAll.getString("max");
          }
        } catch (SQLException e)  {
        }
      }
      if (range.toLowerCase().endsWith("d")) {
          int days = Integer.parseInt(range.substring(0, range.length() -1));
          end = c.simpledf.format(now.getTime());
          now.add(Calendar.DATE, -days);
          start = c.simpledf.format(now.getTime());
          now = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
      }
      else if (range.toLowerCase().endsWith("y")) {
        try {
          int year = Integer.parseInt(range.substring(0, range.length()-1));
          Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
          cal.set(Calendar.YEAR, year);
          cal.set(Calendar.MONTH, Calendar.JANUARY);
          cal.set(Calendar.DAY_OF_MONTH, 1);
          start = c.simpledf.format(cal.getTime());
          cal.set(Calendar.YEAR, year+1);
          end = c.simpledf.format(cal.getTime());
        } catch (IndexOutOfBoundsException e) {
        }
      }
    }

    /*The user entered a custom date range*/
    if (sp != null && ep != null) {
     //Do this to catch any parse errors
      try {
        Date ds = c.simpledf.parse(sp);
        Date de = c.simpledf.parse(ep);
        start = c.simpledf.format(ds);
        end = c.simpledf.format(de);
      } catch (Exception e) {
      }
    }

    path = basePath + Long.toString(System.currentTimeMillis()) + ".png";

    generateGraph(graph, start, end, path);

    /* Read file from disk and write it to response. */
    BufferedInputStream input = null;
    BufferedOutputStream output = null;
    try {
      File imageFile = new File(path);
      response.setContentType("image/png");
      response.setHeader("Content-Length", String.valueOf(
          imageFile.length()));
      response.setHeader("Content-Disposition",
          "inline; filename=\"graph.png\"");
      input = new BufferedInputStream(new FileInputStream(imageFile),
          1024);
      output = new BufferedOutputStream(response.getOutputStream(), 1024);
      byte[] buffer = new byte[1024];
      int length;
      while ((length = input.read(buffer)) > 0) {
          output.write(buffer, 0, length);
      }
    } finally {
      if (output != null)
        output.close();
      if (input != null)
        input.close();
    }
  }

  private void generateGraph(String graph, String start, String end, String path)  {
    String rquery = "plot_" + graph + "('" +
        start + "','" + end + "','" + path +"')";
    //rquery="plot_networksize('" + start + "','" + end + "','" + path + "')";
    try {
      RConnection rc = new RConnection();
      rc.eval(rquery);
      rc.close();
    } catch (Exception e) {
    }
  }
}
