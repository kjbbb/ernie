package org.torproject.ernie.web;

import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.util.*;
import java.util.Date;
import java.text.*;
import java.sql.*;

import org.rosuda.REngine.Rserve.*;
import org.rosuda.REngine.*;

/**
 * Parameterizable graph, generated by R.
 *
 * TODO
 * All requests come from images/graphs/*
 * Get a list of valid graphs for this request, e.g.
 * networksize, exit-relays, etc. Parse parameters,
 * such as range=30d. If the graph is cached and
 * less than an hour old, serve that copy,
 * else regenerate it. All of this depends on whether
 * or not it is a default graph (which will be updated
 * automatically), or a custom graph (which will have
 * to be regenerated).
 */
public class ImageServlet extends HttpServlet {

  Constants c;

  public ImageServlet ()  {
    c = new Constants();
  }

  public void doGet(HttpServletRequest request,
      HttpServletResponse response) throws IOException,
      ServletException {

    Set<String> knownImages = new HashSet<String>(Arrays.asList(
          "72h,30d,90d,180d,all".split(",")));

    String range = request.getParameter("range");
    String sp = request.getParameter("s");
    String ep = request.getParameter("e");
    String basePath = "/tmp/ernie/graphs/";
    String graph = "networksize-";
    String start;
    String end;
    Calendar now = Calendar.getInstance(TimeZone.getTimeZone("UTC"));

    //Set defaults in case anything goes wrong
    //Default is 30 days graph
    now = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
    end = c.simpledf.format(now.getTime());
    now.add(Calendar.DATE, -30);
    start = c.simpledf.format(now.getTime());

    /*The options for the pre-defined graphs from the menu*/
    if (range != null)  {
      if (range.equals("all"))  {
        //Find lowest date and highest date
        try {
          PreparedStatement psAll = c.conn.prepareStatement(
            "select date(min(validafter)) as min, " +
            "date(max(validafter)) as max " +
            "from statusentry"
          );
          ResultSet rsAll = psAll.executeQuery();
          if (rsAll.next())  {
            start = rsAll.getString("min");
            end = rsAll.getString("max");
          }
        } catch (SQLException e)  {
        }
      }
      if (range.toLowerCase().endsWith("d")) {
          int days = Integer.parseInt(range.substring(0, range.length() -1));
          end = c.simpledf.format(now.getTime());
          now.add(Calendar.DATE, -days);
          start = c.simpledf.format(now.getTime());
          now = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
      }
      else if (range.toLowerCase().endsWith("y")) {
        try {
          int year = Integer.parseInt(range.substring(0, range.length()-1));
          Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
          cal.set(Calendar.YEAR, year);
          cal.set(Calendar.MONTH, Calendar.JANUARY);
          cal.set(Calendar.DAY_OF_MONTH, 1);
          start = c.simpledf.format(cal.getTime());
          cal.set(Calendar.YEAR, year+1);
          end = c.simpledf.format(cal.getTime());
        } catch (IndexOutOfBoundsException e) {
        }
      }
    }

    /*The user entered a custom date range*/
    if (sp != null && ep != null) {
     //Do this to catch any parse errors
      try {
        Date ds = c.simpledf.parse(sp);
        Date de = c.simpledf.parse(ep);
        start = c.simpledf.format(ds);
        end = c.simpledf.format(de);
      } catch (Exception e) {
      }
    }

    //graph="/tmp/ernie/graphs/graph.png";
    graph = basePath + graph + Long.toString(System.currentTimeMillis()) + ".png";

    generateGraph(graph, start, end);

    /* Read file from disk and write it to response. */
    BufferedInputStream input = null;
    BufferedOutputStream output = null;
    try {
      File imageFile = new File(graph);
      response.setContentType("image/png");
      response.setHeader("Content-Length", String.valueOf(
          imageFile.length()));
      response.setHeader("Content-Disposition",
          "inline; filename=\"networksize.png\"");
      input = new BufferedInputStream(new FileInputStream(imageFile),
          1024);
      output = new BufferedOutputStream(response.getOutputStream(), 1024);
      byte[] buffer = new byte[1024];
      int length;
      while ((length = input.read(buffer)) > 0) {
          output.write(buffer, 0, length);
      }
    } finally {
      //TODO
      //write an error image on fail
      output.close();
      input.close();
    }
  }

  private void generateGraph(String path, String start, String end)  {
    String[] rgraph = {
      "drv<- dbDriver(\"PostgreSQL\")",
      "con<- dbConnect(drv, user=\"ernie\", password=\"\", dbname=\"tordir\")",
      "rs <- dbSendQuery(con, \"select * from network_size where date >='" + start + "' and date <='" + end + "'\")",
      "networksize <- fetch(rs, n=-1)",
      "networksize <- melt(networksize, id=\"date\")",
      "ggplot(networksize, aes(x = as.Date(date, \"%Y-%m-%d\"), y = value," +
        "colour = variable)) + geom_line() +" +
        "scale_x_date(name=\"\") +" +
        "scale_y_continuous(name=\"\") +" +
        "scale_colour_hue(\"\",breaks=c(\"avg_running\",\"avg_exit\",\"avg_guard\"),labels=c(\"Running\",\"Exit\",\"Guard\"))",
      "ggsave(filename=\"" + path + "\", width=8, height=5, dpi=72)",
      "dbDisconnect(con)",
      "dbUnloadDriver(drv)"
    };
    try {
      RConnection rc = new RConnection();
      for (int i = 0; i < rgraph.length; i++) {
        rc.voidEval(rgraph[i]);
      }
      rc.close();
    } catch (Exception e) {
    }
  }
}
